# Copyright 2013, Big Switch Networks, Inc.
# Copyright 2018, Red Hat, Inc.
#
# LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
# the following special exception:
#
# LOXI Exception
#
# As a special exception to the terms of the EPL, you may distribute libraries
# generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
# that copyright and licensing notices generated by LoxiGen are not altered or removed
# from the LoxiGen Libraries and the notice provided below is (i) included in
# the LoxiGen Libraries, if distributed in source code form and (ii) included in any
# documentation for the LoxiGen Libraries, if distributed in binary form.
#
# Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
#
# You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
# a copy of the EPL at:
#
# http://www.eclipse.org/legal/epl-v10.html
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# EPL for the specific language governing permissions and limitations
# under the EPL.

from collections import namedtuple
from string import Template
from generic_utils import find

import loxi_utils.loxi_utils as loxi_utils
import loxi_globals
import loxi_ir
import loxi_ir.ir_offset as ir_offset
import util

OFTypeData = namedtuple("OFTypeData", ["name", "serialize", "unserialize"])

# Map from LOXI type name to an object with templates for serialize, and unserialize
# Most types are defined using the convenience code below. This dict should
# only be used directly for special cases such as primitive types.
type_data_map = {
    'char': OFTypeData(
        name='byte',
        serialize=Template('encoder.PutChar($member)'),
        unserialize=Template('$member = data[$offset]')),

    'uint8_t': OFTypeData(
        name='uint8',
        serialize=Template('encoder.PutUint8($member)'),
        unserialize=Template('$member = data[$offset]')),

    'uint16_t': OFTypeData(
        name='uint16',
        serialize=Template('encoder.PutUint16($member)'),
        unserialize=Template('$member = binary.BigEndian.Uint16(data[$offset:$offset+2])')),

    'uint32_t': OFTypeData(
        name='uint32',
        serialize=Template('encoder.PutUint32($member)'),
        unserialize=Template('$member = binary.BigEndian.Uint32(data[$offset:$offset+4])')),

    'uint64_t': OFTypeData(
        name='uint64',
        serialize=Template('encoder.PutUint64($member)'),
        unserialize=Template('$member = binary.BigEndian.Uint64(data[$offset:$offset+8])')),

    'uint128_t': OFTypeData(
        name='uint128',
        serialize=Template('encoder.PutUint64($member.Hi)\nencoder.PutUint64($member.Lo)'),
        unserialize=Template('// $member = binary.BigEndian.Uint128(data[$offset:$offset+16])')),

    'of_port_no_t': OFTypeData(
        name='PortNo',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_fm_cmd_t': OFTypeData(
        name='FmCmd',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_wc_bmap_t': OFTypeData(
        name='WcBmap',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_match_bmap_t': OFTypeData(
        name='MatchBmap',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_ipv4_t': OFTypeData(
        name='net.IP',
        serialize=Template('encoder.Write($member.To4())'),
        unserialize=Template('$member = net.IP(data[$offset:$offset+4])')),

    'of_ipv6_t': OFTypeData(
        name='net.IP',
        serialize=Template('encoder.Write($member.To16())'),
        unserialize=Template("$member = net.IP(data[$offset:$offset+16])")),

    'of_mac_addr_t': OFTypeData(
        name='net.HardwareAddr',
        serialize=Template('encoder.Write($member)'),
        unserialize=Template("$member = net.HardwareAddr(data[$offset:$offset+6])")),

    'of_octets_t': OFTypeData(
        name='[]byte',
        serialize=Template('encoder.Write($member)'),
        unserialize=Template('copy($member, data[$offset:])')),

    'of_bitmap_128_t': OFTypeData(
        name='Bitmap128',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_oxm_t': OFTypeData(
        name='OXM',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:])')),

    'of_checksum_128_t': OFTypeData(
        name='Checksum128',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_bitmap_512_t': OFTypeData(
        name='Bitmap512',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_time_t': OFTypeData(
        name='Time',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_controller_uri_t': OFTypeData(
        name='ControllerURI',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_controller_status_entry_t': OFTypeData(
        name='ControllerStatusEntry',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    'of_header_t': OFTypeData(
        name='Header',
        serialize=Template('$member.Serialize(encoder)'),
        unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),

    # 'of_nicira_match_t': OFTypeData(
    #     name='NiciraMatch',
    #     serialize=Template('$member.Serialize(encoder)'),
    #     unserialize=Template('$member.Decode(data[$offset:$offset+$length])')),
}

## Fixed length strings

# Map from class name to length
fixed_length_strings = {
    'of_port_name_t': 16,
    'of_table_name_t': 32,
    'of_serial_num_t': 32,
    'of_desc_str_t': 256,
    'of_str64_t': 64,
}

for (cls, length) in fixed_length_strings.items():
    type_data_map[cls] = OFTypeData(
        name="string",
        serialize=Template('encoder.Write([]byte($member))'),
        unserialize=Template('$member = string(bytes.Trim(data[$offset:$offset+%d], "\\x00"))' % length))

## Embedded structs

# Map from class name to Golang struct name
embedded_structs = {
    'of_match_t': 'Match',
    'of_nicira_match_t': 'NiciraMatch',
    'of_port_desc_t': 'PortDesc',
    'of_meter_features_t': 'MeterFeatures',
    'of_bsn_vport_t': 'BSNVport',
    'of_table_desc_t': 'TableDesc',
    'of_bsn_unit_t': 'BSNUnit',
    'ofp_bsn_module_eeprom_transceiver_t': 'BSNModuleEEPROMTransceiver',
    'of_port_desc_prop_bsn_alarm_t': 'PortDescPropBSNAlarm',
    'of_port_desc_prop_bsn_diag_t': 'PortDescProp_BSNDiag',
    'of_stat_t': 'Stat',
}

for (cls, gotype) in embedded_structs.items():
    type_data_map[cls] = OFTypeData(
        name=gotype,
        serialize=Template('if err := $member.Serialize(encoder); err != nil {\n\t\treturn err\n\t}\n'),
        unserialize=Template('if err := $member.Decode(data[$range]); err != nil {\n\t\treturn err\n\t}\n'))

## Public interface

def lookup_type_data(oftype, version):
    return type_data_map.get(loxi_utils.lookup_ir_wiretype(oftype, version))

def oftype_is_list(oftype):
    return (oftype.find("list(") == 0)

# Converts "list(of_flow_stats_entry_t)" to "of_flow_stats_entry"
def oftype_list_elem(oftype):
    assert oftype.find("list(") == 0
    return oftype[5:-3]

def oftype_has_content(ofclass):
    for member in ofclass.members:
        if type(member) == loxi_ir.OFDiscriminatorMember and hasattr(member, "values"):
            if ofclass.superclass:
                super_member = ofclass.superclass.member_by_name(member.name)
                if type(super_member) == loxi_ir.OFDiscriminatorMember:
                    continue
            return True
    return False

def oftype_get_length(ofclass, member, version):
    if member.is_fixed_length:
        return member.length

    field_length_member = find(lambda m: type(m) == loxi_ir.OFFieldLengthMember and \
                                         m.field_name == member.name, ofclass.members)
    if field_length_member:
        return "self." + util.go_ident(field_length_member.name)

    member_type = member.oftype
    if member_type in ir_offset.of_mixed_types:
        member_type = ir_offset.of_mixed_types[member_type][version.wire_version]

    member_type = member_type[:-2]
    classes = loxi_globals.ir[version].classes
    if member.oftype in classes:
        member_type = classes[member.oftype]
        if member_type.is_fixed_length:
            return member_type.length
        elif member.length_member:
            return "self." + util.go_ident(member.length_member.name)
